<?php

class text_in{
	
	public function __construct(){
	}

	public function main(array $newText, array $fTerms, array $fSettings, array $textInSettings){
		//reformat the cell number so we can search in the database	
		$newText['cell_formatted'] = $this->parse_cell($newText['cell']);
		
		$textInSettings = $this->what_is_this_text_in($newText,$fTerms,$fSettings,$textInSettings);

		$this->react_to_text_in($textInSettings,$newText,$fTerms,$fSettings);

	return $textInSettings;
	}

	private function what_is_this_text_in(array $newText, array $fTerms, array $fSettings, array $textInSettings){
	// This method decides what a text is, so that we can decide how to deal with it

	//We collect data about the message and put it in the dbdata element
	$textInSettings['dbData'] = array	('level' => 0,
										'active' => 0,
										'value' => 0);

	//Get level 1 (independant) details about the new text
	foreach($textInSettings as $function => $setting){
		if(!$setting['active'] == 1) continue;
		if(!$setting['level'] == 1) continue;
		$function = 'check_' . $function;
		if(!method_exists($this,$function)) continue;
		$textInSettings = $this->$function($function,$textInSettings,$newText,$fTerms,$fSettings);
	}
	
	//Get level 2 (dependant) details about the new text
	foreach($textInSettings as $function => $setting){
		if(!$setting['active'] == 1) continue;
		if(!$setting['level'] == 2) continue;
		$function = 'check_' . $function;
		if(!method_exists($this,$function)) continue;
		$textInSettings = $this->$function($function,$textInSettings,$newText,$fTerms,$fSettings);
		}
		
	return $textInSettings;
	}

	private function react_to_text_in($textInSettings,$newText,$fTerms,$fSettings){
		foreach($textInSettings as $function => $setting){
			if(!$setting['value'] == 1) continue;
			$function = 'react_' . $function;
			if(!method_exists($this,$function)) continue;
			$this->$function($function,$textInSettings,$newText,$fTerms,$fSettings);
		}
	}
	
//--- Functions to check for level 1 and level 2 details ---//	
	
	private function check_spam($function,$textInSettings,$newText,$fTerms,$fSettings){
		//sql query for person type = spammer with matching cell number
		$sql = 'select cp.entity_id as spammer_nid
		from {field_data_field_cell_phone cp}
		join {field_data_field_person_type pt} on pt.entity_id = cp.entity_id
		where cp.field_cell_phone_value = :cell_formatted
		and pt.field_person_type_tid = :person_type';

		$args = array(	':cell_formatted' => $newText['cell_formatted'],
						':person_type' => $fTerms['person_types']['spammer']);
		$result = db_query($sql,$args)->fetchAssoc();
		if(!isset($result) or $result == NULL) return $textInSettings;
		$textInSettings['spam']['value'] = 1;
		$textInSettings['dbData']['spammer_nid'] = $result['spammer_nid'];
	
	return $textInSettings;		
	}
	
	private function check_take_job($function,$textInSettings,$newText,$fTerms,$fSettings){
		//Query the database to see if we texted this person in the last x-minutes 
		//(job relay time from settings) and if they are a Fixits
		$sql = "	select n.nid as text_nid,
					n.created as text_time,
					j.field_job_target_id as job_nid,
					cp.entity_id as fixit_nid,
					s.field_status_tid as job_status
		from 		{field_data_field_cell_phone cp}
		join 		{field_data_field_person_type pt} on cp.entity_id = pt.entity_id
		join 		{field_data_field_fixit_ref fr} on fr.field_fixit_ref_target_id = cp.entity_id
		join 		{field_data_field_job j} on j.entity_id = fr.entity_id
		join 		{node n} on n.nid = fr.entity_id
		join		{field_data_field_status s} on s.entity_id = j.field_job_target_id
		where 		cp.field_cell_phone_value = :cell_formatted
		and 		pt.field_person_type_tid = :person_type
		and 		fr.bundle = 'text_out'
		and 		n.created > :jobRelayTime
		order by	n.created desc";
		
		$args = array(	':cell_formatted' => $newText['cell_formatted'],
						':person_type' => $fTerms['person_types']['fixit'], 
						':jobRelayTime' => (time() - $fSettings['job_relay_time']['value'])
						);
		$result = db_query($sql,$args)->fetchAssoc();
		if(!isset($result) or $result == NULL) return $textInSettings;

		//Make sure the word fixit is in the text
		if(!(preg_match('/fixit/',$newText['sms'],$matches))) return $textInSettings;

		$textInSettings['take_job']['value'] = 1;
		$textInSettings['dbData']['take_job_nid'] = $result['job_nid'];
		$textInSettings['dbData']['fixit_nid'] = $result['fixit_nid'];

	return $textInSettings;
	}
	
	private function check_from_fixit($function,$textInSettings,$newText,$fTerms,$fSettings){
		//query to find out if text is from an existing person
		$sql = "	select 		cp.entity_id as person_nid
					from 		field_data_field_cell_phone cp
					join 		field_data_field_person_type pt on pt.entity_id = cp.entity_id
					where 		cp.field_cell_phone_value = :cell_formatted
					and			pt.field_person_type_tid = :person_type
					order by	cp.entity_id desc";

		$args = array(	':cell_formatted' => $newText['cell_formatted'],
						':person_type' => $fTerms['person_types']['fixit']);
		$result = db_query($sql,$args)->fetchAssoc();
		
		if(!isset($result) or $result == NULL) return $textInSettings;
		$textInSettings['from_fixit']['value'] = 1;
		$textInSettings['dbData']['fixit_nid'] = $result['person_nid'];

	return $textInSettings;
	}

	private function check_feedback($function,$textInSettings,$newText,$fTerms,$fSettings){
		//Query for text node where the recipient is a customer with matching cell number
		//and text out type = request_feedback, in the last 2 hours
		$sql = "select cr.entity_id as text_out_nid,
						tt.field_text_type_tid as text_type,
						cr.field_customer_ref_target_id as customer_nid,
						fr.field_fixit_ref_target_id as fixit_nid
		from 			field_data_field_cell_phone cp
		join 			field_data_field_customer_ref cr on cr.field_customer_ref_target_id = cp.entity_id
		join 			field_data_field_text_type tt on tt.entity_id = cr.entity_id
		join 			field_data_field_fixit_ref fr on fr.entity_id = cr.entity_id
		join 			node n on n.nid = cr.entity_id
		where 			cp.field_cell_phone_value = :cell_formatted
		and 			cr.bundle = 'text_out'
		and 			tt.field_text_type_tid = :request_feedback
		and 			n.created > :twoHours";
		
		$args = array(	':cell_formatted' => $newText['cell_formatted'], 
						':request_feedback' => $fTerms['text_out_types']['request_feedback'],
						':twoHours' => (time() - (2*60*60))
						);
		$result = db_query($sql,$args)->fetchAssoc();
		if(!isset($result) or $result == NULL) return $textInSettings;
		$textInSettings['feedback']['value'] = 1;
		$textInSettings['dbData']['feedback_customer_nid'] = $result['customer_nid'];
		$textInSettings['dbData']['feedback_fixit_nid'] = $result['fixit_nid'];
		
	return $textInSettings;		
	}

	private function check_existing_person($function,$textInSettings,$newText,$fTerms,$fSettings){
		//query to find out if text is from an existing person
		$sql = "select cp.entity_id as person_nid
		from field_data_field_cell_phone cp
		where cp.field_cell_phone_value = :cell_formatted
		order by cp.entity_id desc";

		$args = array(':cell_formatted' => $newText['cell_formatted']);
		$result = db_query($sql,$args)->fetchAssoc();
		
		if(!isset($result) or $result == NULL) return $textInSettings;
		$textInSettings['existing_person']['value'] = 1;
		$textInSettings['dbData']['existing_person_nid'] = $result['person_nid'];
		
	return $textInSettings;	
	}

	private function check_add_to_job($function,$textInSettings,$newText,$fTerms,$fSettings){
	//If a job was created for same person in the last minute we add this new 
	//info to that job instead of making a new job

	//if somebody is telling us their zip code, don't add that to a job
	if((preg_match('/[0-9]{5}/',$newText['sms'],$matches))) return $textInSettings;
	
		//query to see if job exists for this cell number within last minute
		$sql = "select cr.entity_id as job_nid,
				cr.field_customer_ref_target_id as customer_nid,
				n.created as when_created
				from field_data_field_cell_phone cp
				join field_data_field_customer_ref cr on cr.field_customer_ref_target_id = cp.entity_id
				join node n on n.nid = cr.entity_id
				where cp.field_cell_phone_value = :cell_formatted
				and cr.bundle = 'job'
				and n.created > :oneMin";

		$args = array(	':cell_formatted' => $newText['cell_formatted'],
						':oneMin' => (time() - 60)
						);
		$result = db_query($sql,$args)->fetchAssoc();
		if(!isset($result) or $result == NULL) return $textInSettings;
		$textInSettings['add_to_job']['value'] = 1;
		$textInSettings['dbData']['add_to_job_nid'] = $result['job_nid'];
		
	return $textInSettings;		
	}
	
	private function check_contains_zip($function,$textInSettings,$newText,$fTerms,$fSettings){
		//check if it contains a five digit number
		if(!(preg_match('/[0-9]{5}/',$newText['sms'],$matches))) return $textInSettings;
		$textInSettings['contains_zip']['value'] = 1;
		$textInSettings['dbData']['contains_zip'] = $matches[0];
		
	return $textInSettings;		
	}
	
	private function check_contains_contractor($function,$textInSettings,$newText,$fTerms,$fSettings){
		//check if it contains a the string contractor
		if(!(preg_match('/contractor/',$newText['sms'],$matches))) return $textInSettings;
		$textInSettings['contains_contractor']['value'] = 1;			
	return $textInSettings;		
	}
	
	private function check_update_zip($function,$textInSettings,$newText,$fTerms,$fSettings){
		if($textInSettings['contains_zip']['value'] == 0) return $textInSettings;
		if($textInSettings['existing_person']['value'] == 0) return $textInSettings;
		
		$textInSettings['update_zip']['value'] = 1;
	return $textInSettings;		
	}

	private function check_new_fixit($function,$textInSettings,$newText,$fTerms,$fSettings){
		//check if this has already been marked as from an existing person
		if($textInSettings['existing_person'] == 1) return $textInSettings;
		
		//if the message doesn't contain the string contractor then it's not a new fixit
		if($textInSettings['contains_contractor']['value'] == 0) return $textInSettings;
		
		$textInSettings['new_fixit']['value'] = 1;
	return $textInSettings;		
	}
	
	private function check_new_customer($function,$textInSettings,$newText,$fTerms,$fSettings){
		//check if this has already been marked as from an existing person
		if($textInSettings['existing_person']['value'] == 1) return $textInSettings;
		
		//return 0 if the text contains the string 'contractor'
		if($textInSettings['contains_contractor']['value'] == 1) return $textInSettings;
		
		$textInSettings['new_customer']['value'] = 1;	
	return $textInSettings;		
	}
	
	private function check_new_job($function,$textInSettings,$newText,$fTerms,$fSettings){
		//if not spam
		if($textInSettings['spam']['value'] == 1) return $textInSettings;
		
		//if not feedback
		if($textInSettings['feedback']['value'] == 1) return $textInSettings;
		
		//if not take_job
		if($textInSettings['take_job']['value'] == 1) return $textInSettings;
		
		//if not add to job
		if($textInSettings['add_to_job']['value'] == 1) return $textInSettings;
		
		//if doesn't contain string contractor
		if($textInSettings['contains_contractor']['value'] == 1) return $textInSettings;
		
		//if not contains zip
		if($textInSettings['contains_zip']['value'] == 1) return $textInSettings;
		
		//if not from fixit
		if($textInSettings['from_fixit']['value'] == 1) return $textInSettings;

		//then we can say it is a new job
		$textInSettings['new_job']['value'] = 1;
		
	return $textInSettings;		
	}
	
//--- Functions to react to level 1 and level 2 details ---//	

	private function react_spam($function, array $textInSettings, array $newText, array $fTerms, array $fSettings){
		if(isset($textInSettings['dbData']['spammer_nid'])){
			$j1 = new job();
			$j1->main($textInSettings['dbData']['spammer_nid'],
						'',
						$newText['sms'],
						$newText['mms'],
						$fTerms['job_statuses']['denied']
						);
		}
	}

	private function react_take_job($function, array $textInSettings, array $newText, array $fTerms, array $fSettings){		
		if(isset($textInSettings['dbData']['take_job_nid'])){
			$j1 = new job();
			$j1->set_job_status($textInSettings['dbData']['take_job_nid'],
								$fTerms['job_statuses']['taken_not_notified_customer']);
								
			$j1->set_job_fixit($textInSettings['dbData']['take_job_nid'],
								$textInSettings['dbData']['fixit_nid']);
		}
	}

	private function react_feedback($function, array $textInSettings, array $newText, array $fTerms, array $fSettings){		
		if(isset($textInSettings['dbData']['feedback_customer_nid']) &&
			isset($textInSettings['dbData']['feedback_fixit_nid'])){
				$f1 = new feedback();
				$f1->new_feedback_node($textInSettings['dbData']['feedback_customer_nid'],
										$textInSettings['dbData']['feedback_fixit_nid'],
										$newText['sms']);
			}
	}

	private function react_add_to_job($function, array $textInSettings, array $newText, array $fTerms, array $fSettings){
		$j1 = new job();
		$j1->set_job_sms_mms($textInSettings['dbData']['add_to_job_nid'],
							$newText['sms'],
							$newText['mms']);
	}

	private function react_update_zip($function, array $textInSettings, array $newText, array $fTerms, array $fSettings){		
		if(isset($textInSettings['dbData']['existing_person_nid']) &&
			isset($textInSettings['dbData']['contains_zip'])){
				$p1 = new person();
				$p1->set_person_zip($textInSettings['dbData']['existing_person_nid'],
									$textInSettings['dbData']['contains_zip']);
		}
	}

	private function react_new_fixit($function, array $textInSettings, array $newText, array $fTerms, array $fSettings){
		if($textInSettings['contains_zip']['value'] == 1){
			$zip = $textInSettings['dbData']['contains_zip'];
		}else{
			$zip = '';
		}
			
		$f1 = new person();
		$fixitNid = $f1->new_person_node($newText['cell_formatted'],
						$fTerms['person_types']['fixit'],
						'',
						'',
						$zip)->nid;
	}

	private function react_new_customer($function, array $textInSettings, array $newText, array $fTerms, array $fSettings){		
		if($textInSettings['contains_zip']['value'] == 1){
			$zip = $textInSettings['dbData']['contains_zip'];
		}else{
			$zip = '';
		}

		$j1 = new person();
		$j1->new_person_node($newText['cell_formatted'],
							$fTerms['person_types']['customer'],
							'',
							'',
							$zip);
	}

	private function react_new_job($function, array $textInSettings, array $newText, array $fTerms, array $fSettings){
		$sql = "select		cp.entity_id as customer_nid
				from 		{field_data_field_cell_phone cp}
				where 		cp.field_cell_phone_value = :cell_formatted";
		
		$args = array(':cell_formatted' => $newText['cell_formatted']);
		$result = db_query($sql,$args)->fetchAssoc();
		if(!isset($result) or $result == NULL) return;

		$j1 = new job();
		$j1->main($result['customer_nid'],
					'',
					$newText['sms'],
					$newText['mms'],
					$fTerms['job_statuses']['needs_approval']);
	}

// --- Other functions ---//	

	private function parse_cell($cell){
		//format the cell number like (111) 222-3333 because of the idiots who wrote the phone field module
		$cell_formatted = 0;
		
		if(is_numeric($cell) && strlen($cell) == 10){
			$area = substr($cell,0,3);
			$exch = substr($cell,3,3);
			$four = substr($cell,6,4);
			$cell_formatted = '(' . $area . ') ' . $exch . '-' . $four;
		}
	return $cell_formatted;
	}

}